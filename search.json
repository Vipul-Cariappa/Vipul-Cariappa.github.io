[
  {
    "objectID": "projects/index.html",
    "href": "projects/index.html",
    "title": "Projects | Vipul Cariappa",
    "section": "",
    "text": "PyC is a general purpose binding between Python Programming Language and C/C++. My goal behind developing this binding is to enable the use of C/C++ libraries inside Python with very few to no modifications to the source libraries and without any recompilations of the original library. Currently PyC only works on linux machines where the library is compiled to a shared object (.so file / dynamic library). PyC is purely written in C. It depends on libclang to parse the header file of the library to identify function symbols available and their parameter types and typedefs, structs, unions and enums. PyC is actively being developed and is not bug free yet. You can find the link to the source here."
  },
  {
    "objectID": "projects/index.html#pyc",
    "href": "projects/index.html#pyc",
    "title": "Projects | Vipul Cariappa",
    "section": "",
    "text": "PyC is a general purpose binding between Python Programming Language and C/C++. My goal behind developing this binding is to enable the use of C/C++ libraries inside Python with very few to no modifications to the source libraries and without any recompilations of the original library. Currently PyC only works on linux machines where the library is compiled to a shared object (.so file / dynamic library). PyC is purely written in C. It depends on libclang to parse the header file of the library to identify function symbols available and their parameter types and typedefs, structs, unions and enums. PyC is actively being developed and is not bug free yet. You can find the link to the source here."
  },
  {
    "objectID": "projects/index.html#scivis",
    "href": "projects/index.html#scivis",
    "title": "Projects | Vipul Cariappa",
    "section": "SciVis",
    "text": "SciVis\nSciVis stands for Scientific Visualizer. Even though it is called Scientific Visualizer it should have actually been MathVis, because all the visualizations available right now are related to mathematics. With this you can visualize or graph any mathematical function. SciVis can also compute and visualize Taylor series and Fourier series of any given function. SciVis can calculate integral and derivative of any given function and graph it. SciVis also provides a truth table generator. There are many more visualizations planned to be implemented and development is still going on. The site is developed using svelte and the backend is developed in fastAPI. You can find the source code here."
  },
  {
    "objectID": "projects/index.html#py-lua",
    "href": "projects/index.html#py-lua",
    "title": "Projects | Vipul Cariappa",
    "section": "py-lua",
    "text": "py-lua\nSimilar to PyC, py-lua is also a general purpose binding. This time it is between Python Programming Language and Lua Programming Language. Py-lua lets you use any lua module inside of python and also allows the use of any python module inside lua. It converts data types between the two languages seamlessly and also supports Object Oriented Programming features. Py-lua can also propagate exceptions raised in one language to the other language. It is written in C Programming Language. You can find the source here."
  },
  {
    "objectID": "projects/index.html#coder",
    "href": "projects/index.html#coder",
    "title": "Projects | Vipul Cariappa",
    "section": "coder",
    "text": "coder\nInspired from competitive programming sites like leetcode and codewars. I wanted to know how these sites are implemented. So I created my own version of it. Here you can create your own questions also, to which you need to write a solution and also the test cases to verify if the answer is correct. You can find the source here and the site here."
  },
  {
    "objectID": "projects/index.html#expenses-recorder",
    "href": "projects/index.html#expenses-recorder",
    "title": "Projects | Vipul Cariappa",
    "section": "Expenses Recorder",
    "text": "Expenses Recorder\nThis web site will help you manage your daily expenses. This site allows a user to form groups and collectively track expenses. A user can form groups and share its name and password with others to join the group. Members in a group can add, edit and delete bill’s created. Creator of a group has the ability to remove an existing member from the group or/and delete the group. You can find the source here."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-First-2-Weeks/index.html",
    "href": "blogs/posts/GSoC'24-LPython-First-2-Weeks/index.html",
    "title": "GSoC’24 - LPython: First Two Week",
    "section": "",
    "text": "The last 2 weeks were rough. With the existing implementation of Just-In-Time (JIT) compilation we use for REPL, we were facing issues on Windows. Say you declare a function f in the first REPL block, and function g in the second block. Such that function g calls the function f. And in the 3rd block, you call g; JIT would not be able to locate the function f. We were facing this issue only on Windows. Currently, on Windows, we are not able to compile with debug symbols; We use the LLVM provided by the conda package manager, the LLVM version it provides, and the MSVC compiler we use in Windows, together do not allow a debug build. This inability to have a debug build made it very difficult to get to the source of the problem we were facing. With lots of trial and error, I fixed the issue. I referred to LLVM’s documentation on using JIT and adapted our existing implementation accordingly.\nA lot of my work focuses on libasr. As the libasr is shared between LFortran and LPython, many of the changes introduced to libasr need to be tested in both LFortran and LPython."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-First-2-Weeks/index.html#merged-pull-requests",
    "href": "blogs/posts/GSoC'24-LPython-First-2-Weeks/index.html#merged-pull-requests",
    "title": "GSoC’24 - LPython: First Two Week",
    "section": "Merged Pull Requests",
    "text": "Merged Pull Requests\n\nFix array symbol duplication in interactive mode (In LFortran) This PR fixed a bug in which array symbols would be duplicated for each REPL evaluation loop. I believe this issue persists in LPython and needs to be fixed there.\nFix ASR verify pass error while using Interactive (In LFortran) The structure of the ASR is verified using asr_verify function. In the interactive mode, we remove the body of the functions executed in the previous REPL block and only keep its declaration. Due to this, asr_verify would fail. I had to make changes to asr_verify so that it works in the interactive mode.\nI added the ability to print the top-level expressions in REPL. As of now this printing of top-level expressions only works for primitive types. I will be adding in the ability to print aggregate datatypes like list, tuple, dict, etc., in the upcoming week. I have also written the necessary test cases. Related pull requests (In LPython):\n\nInitial test for Interactive\nPrinting top-level Expressions\nSupport to print u32 and u64 in REPL\nSupport to print i8, u8, i16 and u16 in Interactive mode\nREPL str support"
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-First-2-Weeks/index.html#open-pull-requests",
    "href": "blogs/posts/GSoC'24-LPython-First-2-Weeks/index.html#open-pull-requests",
    "title": "GSoC’24 - LPython: First Two Week",
    "section": "Open Pull Requests",
    "text": "Open Pull Requests\n\nFix ASR verify pass error while using Interactive This PR contains the same changes as previously mentioned, but for LPython.\nSupport logical values when using interactive (In LFortran) Support to print logical/boolean datatypes in REPL. This change should also be implemented in LPython."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-First-2-Weeks/index.html#issues-opened",
    "href": "blogs/posts/GSoC'24-LPython-First-2-Weeks/index.html#issues-opened",
    "title": "GSoC’24 - LPython: First Two Week",
    "section": "Issues Opened",
    "text": "Issues Opened\n\nBlank line within an indented block of code is wrongly parsed on Windows\n\n\nFor the next week, I plan to continue working on implementing the ability to print top-level expressions for the remaining data types that are not yet implemented. Hopefully, I will not be stuck like the last 2 weeks with a difficult to debug problem."
  },
  {
    "objectID": "blogs/posts/GSoC'23-GNU-Octave-First-Week/index.html",
    "href": "blogs/posts/GSoC'23-GNU-Octave-First-Week/index.html",
    "title": "GSoC’23 - GNU Octave: Week 1",
    "section": "",
    "text": "This is an account of all the things I have done during the community bonding period and the 1st week of the Google Summer of Code (GSoC) 2023. You can find more details about my GSoC 2023 project here.\n\nUpdate the CI/CD pipeline with the official GNU Octave image to use while testing. Testing with multiple versions of GNU Octave and Python which Pythonic currently supports. Link to the merge request. This MR has been merged.\nImplementation of pyimport command to import Python modules, functions and namespace into Octave workspace. The concept was appreciated, but there are some shortcomings in actually pushing it to the main branch of the project. pyimport command is a hack to support function handles, MATLAB does not provide such a command, and maintaining it, in the long run, may cause problems. I have opened a merge request with my implementation of pyimport which may or may not be merged. You can find it here.\nImplementation of destructor (delete) of @pyobject. Now Python objects are freed from memory when they go out of scope. Link to merge request. This MR is currently under review and is not yet been merged.\nAdded a new page in Pythonic Wiki with reference API documentation for developers and users of Pythonic.\nStarted a discourse discussion on a bug octave crashing while saving class object to a file. This bug now has been fixed.\nFiled two bug reports at Savannah on octave crashing while using subsasgn with struct and multiple subs value and destructor being executed even if the constructor fails and throws an error.\n\n\nDuring my first meeting with my mentors, I told them that in the first week, I wanted to figure out a few things on how I will be implementing some of my deliverables., and will tinker with Octave and Pythonic project during first week. Below you will find what I have done/tinkered with this week.\n\nInfo related to pyenv function\nMATLAB offers a function pyenv to select the Python version to be used. Currently Pythonic does not offer pyenv function, nor has any mechanism to change or select Python version to use. While compiling Pythonic we link it directly to a specified Python version. Say we compiled Pythonic with Python 3.10, but we want to use Python 3.11. We will need to recompile the entire code base and link it to Python 3.11. And this will end up breaking Python 3.10.\nI have asked a question at StackOverFlow for a method to select a Python version to use at runtime. I have not gotten an answer as of the time I am writing this blog. But I have managed to figure out a way myself. A means to choose a Python version is by not linking the final shared library (i.e. .oct file) with any Python version. Instead, we can load the desired version of Python using dlopen, just before initializing Python. Then we will be able to use any specified version of Python. Python also offers stable ABI (Application Binary Interface), using it we can set Py_LIMITED_API to the minimum Python version we want to support.\nThe general idea will be the following\nif (version == \"3.11\") {\n    dlopen(\"python311.so\", RTLD_GLOBAL | RTLD_DEEPBIND | RTLD_NOW);\n} else if (version == \"3.10\") {\n    dlopen(\"python310.so\", RTLD_GLOBAL | RTLD_DEEPBIND | RTLD_NOW);\n} else {\n    // system default\n    dlopen(\"python39.so\", RTLD_GLOBAL | RTLD_DEEPBIND | RTLD_NOW);\n}\nIn Linux machines only adding a dlopen function call should be sufficient for it to work. But in Windows, we may manually need to resolve all the functions from python39.dll that we are going to use.\nExample:\n#include &lt;dlfcn.h&gt;\n#include \"Python.h\"\n\ndlopen(\"/path/to/python39.so\");\n\n// continuation of program\nPy_Initialize();\n...\nPy_Finalize()\nThe above code will work in Linux.\nBut in Windows, we may need to do this\n#include &lt;Windows.h&gt;\n\nvoid *ptr = LoadLibrary(\"python39.dll\");\n\n// resolving functions\nvoid (*Py_Initialize)(void) = GetProcAddress(ptr, \"Py_Initialize\");\n...\nvoid (*Py_Finalize)(void) = GetProcAddress(ptr, \"Py_Finalize\");\n\n// continuation of program\nPy_Initialize();\n...\nPy_Finalize();\n\nWindows does not offer dlopen. LoadLibrarry from Windows.h is used to do the same as dlopen in Windows.\n\nI am still tinkering with the compiler and linker trying to figure out a way to not have to resolve all the functions from python39.dll in Windows.\n\n\nInfo related to Windows compatibility\nOctave in Windows ships with its own gcc to compile .oct files. It also has its own Python. Octave needs some environment variables set to its own gcc to compile C++ files to .oct files. When lunching octave CLI, these environment variables are not set correctly, but lunching octave GUI sets all the necessary environment variables., and you can compile C++ to .oct files without any errors. There is one more error one may encounter when compiling Pythonic; Not finding the necessary header files while compiling. By default, Octave tries to compile Pythonic against the Python which is bundled with Octave. But compiling with the Python bundled with Octave fails because it does not find the necessary header files. Setting PYTHON environment variable to the full path to the system’s Python executable solves this problem. Pythonic is compiled properly and can be run easily.\nI compiled Pythonic on my local Windows machine with Python 3.10 and Python 3.11. It works as expected. While running tests, it fails one test. That is because somewhere a 64-bit number is stored as a 32-bit number. It can be fixed by changing PyLong_AsUnsignedLong to PyLong_AsUnsignedLongLong in line 215 of src\\oct-py-util.cc. But checking all the places where PyLong_AsUnsignedLong is used to make sure no new bugs emerge later is recommended.\n\nWith the one mentioned change above. All the tests pass in Octave 8.2 with Python 3.10 and Python 3.11., and Octave 7.2 with Python 3.10 and 3.11.\n\n\nThe 64-bit number being stored as 32-bit may be linked to this issue."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Week-4-and-5/index.html",
    "href": "blogs/posts/GSoC'24-LPython-Week-4-and-5/index.html",
    "title": "GSoC’24 - LPython: 4th & 5th Week",
    "section": "",
    "text": "I enjoyed the work this week. It was interesting and challenging at the same time.\nI mainly worked on 2 things this week; Support to print top-level expressions in REPL of aggregate datatypes like list, tuple, dict, set and classes, and Support for redefinitions of functions.\nSupport to Print Top-Level Expression in REPL of Aggregate Datatypes\nLike I have mentioned in the previous blog, list[i32] in LLVM is represented as %list = type { i32, i32, i32* }. I updated the global_stmt function that gets generated to return the list so that we can print it externally. Looking at the LLVM representation I assumed we could just typecast the result to struct {int32_t; int32_t; int32_t*;}. But using this typecast we were not able to get the correct values. Here the first int32_t is size, the second is capacity and the pointer points to heap heap-allocated array. We were only able to get the size, the other 2 fields were not filled or filled with garbage value. I suspect that LLVM JIT uses some other calling conventions (i.e. ABI), than what is used in C/C++ when it comes to structs.\nThe second, approach I came up with, is to return the pointer to the address that stores the list, then we use LLVM’s API to get the offsets of all the struct elements, use the type info we use while generating LLVM IR to print the list. This approach presently works. I have not yet tested this method with lists, but it works with tuples of any mixture of primitive datatypes. Therefore I assume this will work with list also.\nI now need to finish this implementation and open a pull request. I will be working on it this week.\nSupport for Re-Definitions of Function\nWhile using interactive mode each function is compiled to separate LLVMModule, and moved into the JIT with a ResourceTracker associated with it. All of the LLVMModule’s ResourceTrackers are stored in a hash map, where the keys are the function name. Whenever we find a redefinition of the same function, we remove the ResourceTracker associated with the previous definition, so the function is removed from JIT. The LLVM’s tutorial uses the same approach, I just adapted our codebase to do the same.\nThis causes a bug; Say some function g calls function f (Here f should be defined before defining g). After defining g we redefine f, then we will get a segfault when calling g. To fix this; we know that g depends on f, and f is redefined, then redefine all the functions that depend on f. So g would be calling the new redefined f and not the old f.\nWhile discussing this in the last meeting, we were checking the behavior of CPython and found out that; Say we set some function pointer or variable fp to f and then redefine g. In CPythonfp refers to the old function and not the new function, so we cannot deallocate the old definition of f. Then to support redefinitions we could mangle function names at redefinitions. But g should point to the new definition of f (which may be f1 due to name mangling) and not the old definition of f.\nExample Code:\nDue to the above mentioned behaviors, my mentor Ondrej asked me to hold further development till we could come up with a simpler plan to implement this."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Week-4-and-5/index.html#open-pull-requests",
    "href": "blogs/posts/GSoC'24-LPython-Week-4-and-5/index.html#open-pull-requests",
    "title": "GSoC’24 - LPython: 4th & 5th Week",
    "section": "Open Pull Requests",
    "text": "Open Pull Requests\n\nfix array symbol duplication in interactive mode"
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Week-6/index.html",
    "href": "blogs/posts/GSoC'24-LPython-Week-6/index.html",
    "title": "GSoC’24 - LPython: 6th Week",
    "section": "",
    "text": "This week was fun. Most of the things went smoothly this week.\nNext week is GSoC’s mid-term evaluation."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Week-6/index.html#open-pull-requests",
    "href": "blogs/posts/GSoC'24-LPython-Week-6/index.html#open-pull-requests",
    "title": "GSoC’24 - LPython: 6th Week",
    "section": "Open Pull Requests",
    "text": "Open Pull Requests\n\nSupport to print lists in REPL Adds support to print top-level expression of list type.\nCI tests for LLVM 10, 14, 15 and 16 LPython’s sister project LFortran tests its code base with multiple versions of LLVM. As LPython and LFortran share a lot of code, I am setting an automated CI workflow to build and run LPython with different versions of LLVM we intend to support. The versions selected are the ones LFortran supports and has automated CI workflow for. The CI passes all the tests for all versions of LLVM other than 14. I am not able to reproduce the bug on my local computer as of now.\nUnderscore: _ variable in REPL This PR introduces the _ (underscore) variable in LPython’s REPL (like in CPython’s REPL). The _ variable holds the value of the last evaluated expression from the previous REPL block.\nImplement Jupyter kernel Implementation of Jupyter Kernel for LPython. The code is adapted from LFortran’s Kernel implementation."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Week-6/index.html#merged-pull-requests",
    "href": "blogs/posts/GSoC'24-LPython-Week-6/index.html#merged-pull-requests",
    "title": "GSoC’24 - LPython: 6th Week",
    "section": "Merged Pull Requests",
    "text": "Merged Pull Requests\n\nfix array symbol duplication in interactive mode"
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Week-6/index.html#pull-requests-on-hold",
    "href": "blogs/posts/GSoC'24-LPython-Week-6/index.html#pull-requests-on-hold",
    "title": "GSoC’24 - LPython: 6th Week",
    "section": "Pull Requests On-Hold",
    "text": "Pull Requests On-Hold\n\nSupport to redefine of function in REPL Implementation of redefinitions of functions in LFortran’s interactive mode. Please read the previous blog for details on why this PR is on hold.\n\nI will be working on supporting to print of top-level expressions of other aggregate datatypes in REPL upcoming week. Some of the tests for existing PRs fail in GitHub CI, I will be looking into it."
  },
  {
    "objectID": "blogs/posts/GSoC'23-GNU-Octave-Completion/index.html",
    "href": "blogs/posts/GSoC'23-GNU-Octave-Completion/index.html",
    "title": "GSoC’23 - GNU Octave: Project Completion",
    "section": "",
    "text": "My project focused on improving the state of the octave-pythonic package of Octave. Octave-Pythonic provides support to use/call Python functions, modules and classes from within Octave REPL. Octave-Pythonic aims to be MATLAB compatible.\nMy goal for the project was to fix bugs, add in many of the missing features, support the latest version of Python and fix issues related to using Octave-Pythonic on Windows."
  },
  {
    "objectID": "blogs/posts/GSoC'23-GNU-Octave-Completion/index.html#project-overview",
    "href": "blogs/posts/GSoC'23-GNU-Octave-Completion/index.html#project-overview",
    "title": "GSoC’23 - GNU Octave: Project Completion",
    "section": "",
    "text": "My project focused on improving the state of the octave-pythonic package of Octave. Octave-Pythonic provides support to use/call Python functions, modules and classes from within Octave REPL. Octave-Pythonic aims to be MATLAB compatible.\nMy goal for the project was to fix bugs, add in many of the missing features, support the latest version of Python and fix issues related to using Octave-Pythonic on Windows."
  },
  {
    "objectID": "blogs/posts/GSoC'23-GNU-Octave-Completion/index.html#overview-of-the-work-done",
    "href": "blogs/posts/GSoC'23-GNU-Octave-Completion/index.html#overview-of-the-work-done",
    "title": "GSoC’23 - GNU Octave: Project Completion",
    "section": "Overview of the Work Done",
    "text": "Overview of the Work Done\n\nSome of the work mentioned below is not merged into the main branch of the project. I will try and update this blog post when they eventually get merged. Please look at the end for any new updates.\n\n\nThe Octave-Pythonic repository was initially hosted and maintained by a single person. We moved the repository under the GNU Octave project on GitLab.\nOctave-Pythonic supported Python version up to 3.9. Now it has been updated to support the latest Python version 3.11. During this change, we also dropped support to Python 2 and Python versions less than 3.7 (Link to closed Merge Request).\nThe CI/CD pipeline on GitLab was updated to use the official Docker image hosted by GNU Octave for testing. We are running our test suit against multiple versions of Python and multiple versions of Octave to ensure proper support. We could not implement automated testing on Windows by the end of GSoC. There were multiple issues we faced with Windows (Link to closed Merge Request).\nI have provided a proof of concept for pyimport command. pyimport lets the user import Python functions, classes, modules and namespaces into the Octave REPL. The proof of concept was appreciated by was not merged because MATLAB does not offer any similar mechanism (Link to the implementation).\nI have provided a proof of concept of a wrapper around Octave objects so that they can be used within the Python interpreter. The main idea is to use a single object within both the interpreters without any copies. I managed to get the basic idea working. But this feature breaks compatibility with MATLAB, so the changes are not merged (Link to the implementation).\nSupport performing arithmetic and other operations on Python objects (Link to open Merge Request. Not yet merged).\nImprovement to Windows compatibility.\n\nI found the main cause of the failing installation of Octave-Pythonic on Windows. On Windows, Octave bundles its own version of Python. That version is a minimal version that cannot be used to build Python packages. This has now been documented and updated instruction to install Octave-Pythonic on Windows is available (Link to closed Merge Request).\nWe could not get the automated testing on GitLab pipelines working to test Octave-Pythonic on Windows. At present, we manage to get Octave installed, but for some reason, it looks like it does not do anything (Link to open Merge Request. Not yet merged).\n\nPython Objects were not freed from memory after its use. This is fixed and implemented (Link to open Merge Request. Not yet merged).\nVerification of existing issues on the Octave interpreter which needs to be fixed to be used in Pythonic (The following are the ones that still require work).\n\nSupport to access dict items We can access elements from dict using dict_name{\"key\"}, but assigning elements using dict_name{\"key\"} = value gives a syntax error.\nFunction handles to Python functions, bound methods, or other callable objects We can not create any handles to Python objects. It may require detection of the usage of @ within the pyobject, which cannot be done as of now. There may also be some other way to implement it.\nPython objects can’t be loaded or saved using the Octave load and save commands We are waiting for HDF5 file I/O support in Octave to implement this functionality. Currently, Octave does not support HDF5 file I/O.\nStack trace is not returned on error This required the implementation of MException. Which is not implemented.\nIterating through Python object using for loop This will again require support from the Octave interpreter to implement some kind of mechanism to iterate over classdef object.\n\nWe have implemented pyenv function. pyenv is a MATLAB compatible function used to select a Python version to use when using Octave-Pythonic (Link to open Merge Request. Not yet merged).\nWe have added in new page on the Pythonic Wiki page with reference API documentation.\nWe created multiple releases. The release v0.1.3 was done by me."
  },
  {
    "objectID": "blogs/posts/GSoC'23-GNU-Octave-Completion/index.html#other-things-i-worked-on-during-gsoc",
    "href": "blogs/posts/GSoC'23-GNU-Octave-Completion/index.html#other-things-i-worked-on-during-gsoc",
    "title": "GSoC’23 - GNU Octave: Project Completion",
    "section": "Other things I worked on during GSoC",
    "text": "Other things I worked on during GSoC\n\nThese include bug reports and other contributions to the GNU Octave project directly or other affiliated projects.\n\n\nContributions to the oct-hdf5 repository which tries to provide MATLAB compatible HDF5 file I/O functionally.\n\nAutomated testing on GitHub workflow\nImplementation of H5A.get_num_attrs\nDraft implementation of h5disp\n\nOpened discourse topic related to bugs in Octave\n\nOctave CLI does not show any error message on Windows (This has been fixed now)\nOctave exit code does not work on Windows (This has been fixed now)\nWrong link shown in the Community topics related to release of a package (This has been fixed now)\nOctave crashes while saving data to file (This has been fixed now)\n“panic: impossible state reached” while using subsasgn with struct and multiple subs value (This has been fixed now)\n\nFiled issues on GNU Octave’s bug tracker\n\nOctave crashes while saving class object to file (This has been fixed now)\n\nOpened code changes on GNU Octave’s patch tracker\n\nFix to the above mentioned bug of the wrong exit code on Windows (The patch submitted has been merged)\n\n\n\n\nLinks to other Blog posts on GSoC\n\nGSoC Blog: My Project\nGSoC Week 1 Blog\nGSoC First 5 Weeks Blog"
  },
  {
    "objectID": "blogs/posts/glorified-summery-Automated-Theorem-Provers/index.html",
    "href": "blogs/posts/glorified-summery-Automated-Theorem-Provers/index.html",
    "title": "Glorified Summery: Automated Theorem Provers",
    "section": "",
    "text": "In mathematics creating or coming up with a proof is a difficult procedure. The proof we do come up with can contain errors and mistakes that need to be checked and verified for. Computerisation of mathematical proofs could potentially speed up the process of generating and verifying the correctness of proofs. Computerisation of mathematics proofs begins by defining a formal language that can represent complex mathematical statements.\nThe most common such representation is First Order Logic (FOL). First order logic is also called predicate logic or predicate calculus (Wikipedia The Free Encyclopedia, First Order Logic, 2024). First order logic describes a meta-language using which you could describe the actual language you want to use. First order language used constant symbols, variable symbols (there can be free variable and bound variable), function symbols of n-ary, predicates symbols of n-ary, and logical symbols and syntax and semantic rules defining what makes a well formed statement. For example, the mathematical statement of additive inverse would be represented as \\[\\forall x . \\exists y . x + y = 0\\] The statement is read as for all x there exists y such that their sum is zero. Here, \\(\\forall\\), \\(\\exists\\) are logical symbols, \\(0\\) is a constant symbols, \\(x\\) and \\(y\\) are bound variable symbols, \\(+\\) is a binary function in infix notation, and \\(=\\) can be thought of as a predicate. First order logic requires an additional information regarding the proving machinism, that describes how to construct new valid well formed mathematical statements from existing ones. This proving machinism is in the form of rules of inference (Wikipedia The Free Encyclopedia, Rules of Inference, 2024). An example for a rule of inference commonly used in first order logic is Modus Ponen \\[(p) \\land (p \\to q) \\implies q\\] Given that; if \\(p\\) then \\(q\\), and we know that \\(p\\) is true, then it follows that \\(q\\) must be true.\nFirst order logic may not be required to represent some simple statements where we could only use Zeroth Order Logic also called propositional logic (Wikipedia The Free Encyclopedia, Propositional calculus, 2024). Similarly, first order logic might be inadequate to represent more complex mathematical statements where Second Order Logic or Higher Order Logic may be using (Wikipedia The Free Encyclopedia, Higher Order Logic, 2024). For example, there is no way in first order logic to identify the set of all cubes and tetrahedrons. But the existence of this set can be asserted in second-order logic as \\[\\exists P. \\forall x . (P(x) \\leftrightarrow Cube(x) \\lor Tet(x))\\]\nAnother representation is Type Theory. A Type Theory is the formal presentation of a specific type system (Wikipedia The Free Encyclopedia, Type Theory, 2024). Type theory is the academic study of type systems. Some type theories serve as alternatives to set theory as a foundation of mathematics. Two influential type theories that have been proposed as foundations are: - Typed λ-calculus of Alonzo Church (Helmut Brandl, 2024) - Intuitionistic type theory of Per Martin-Löf (Hall, J. G., ed. Intuitionistic Type Theory)\nGiven a formal definition for what constitutes as a valid well formed mathematical statement with syntax and semantics to represent it, along with formal definition to construct proofs, we could develop computer programs to verify and generate proofs.\nExamples of Automated Theorem Provers that use Formal Logic are - Vampire (Vampire, 2024) - E (The E Theorem Prover, 2024) - Z3 Theorem Prover (GitHub, The Z3 Theorem Prover, 2024)\nExamples of Automated Theorem Provers that use Type Theory are - LEAN (Programming Language and Theorem Prover - LEAN, 2024) - Coq (The Coq Proof Assistant, 2024) LEAN and Coq are not fully automated provers, but can be used to verify proofs and works as an computer assistant for mathematicians using it."
  },
  {
    "objectID": "blogs/posts/glorified-summery-Automated-Theorem-Provers/index.html#introduction",
    "href": "blogs/posts/glorified-summery-Automated-Theorem-Provers/index.html#introduction",
    "title": "Glorified Summery: Automated Theorem Provers",
    "section": "",
    "text": "In mathematics creating or coming up with a proof is a difficult procedure. The proof we do come up with can contain errors and mistakes that need to be checked and verified for. Computerisation of mathematical proofs could potentially speed up the process of generating and verifying the correctness of proofs. Computerisation of mathematics proofs begins by defining a formal language that can represent complex mathematical statements.\nThe most common such representation is First Order Logic (FOL). First order logic is also called predicate logic or predicate calculus (Wikipedia The Free Encyclopedia, First Order Logic, 2024). First order logic describes a meta-language using which you could describe the actual language you want to use. First order language used constant symbols, variable symbols (there can be free variable and bound variable), function symbols of n-ary, predicates symbols of n-ary, and logical symbols and syntax and semantic rules defining what makes a well formed statement. For example, the mathematical statement of additive inverse would be represented as \\[\\forall x . \\exists y . x + y = 0\\] The statement is read as for all x there exists y such that their sum is zero. Here, \\(\\forall\\), \\(\\exists\\) are logical symbols, \\(0\\) is a constant symbols, \\(x\\) and \\(y\\) are bound variable symbols, \\(+\\) is a binary function in infix notation, and \\(=\\) can be thought of as a predicate. First order logic requires an additional information regarding the proving machinism, that describes how to construct new valid well formed mathematical statements from existing ones. This proving machinism is in the form of rules of inference (Wikipedia The Free Encyclopedia, Rules of Inference, 2024). An example for a rule of inference commonly used in first order logic is Modus Ponen \\[(p) \\land (p \\to q) \\implies q\\] Given that; if \\(p\\) then \\(q\\), and we know that \\(p\\) is true, then it follows that \\(q\\) must be true.\nFirst order logic may not be required to represent some simple statements where we could only use Zeroth Order Logic also called propositional logic (Wikipedia The Free Encyclopedia, Propositional calculus, 2024). Similarly, first order logic might be inadequate to represent more complex mathematical statements where Second Order Logic or Higher Order Logic may be using (Wikipedia The Free Encyclopedia, Higher Order Logic, 2024). For example, there is no way in first order logic to identify the set of all cubes and tetrahedrons. But the existence of this set can be asserted in second-order logic as \\[\\exists P. \\forall x . (P(x) \\leftrightarrow Cube(x) \\lor Tet(x))\\]\nAnother representation is Type Theory. A Type Theory is the formal presentation of a specific type system (Wikipedia The Free Encyclopedia, Type Theory, 2024). Type theory is the academic study of type systems. Some type theories serve as alternatives to set theory as a foundation of mathematics. Two influential type theories that have been proposed as foundations are: - Typed λ-calculus of Alonzo Church (Helmut Brandl, 2024) - Intuitionistic type theory of Per Martin-Löf (Hall, J. G., ed. Intuitionistic Type Theory)\nGiven a formal definition for what constitutes as a valid well formed mathematical statement with syntax and semantics to represent it, along with formal definition to construct proofs, we could develop computer programs to verify and generate proofs.\nExamples of Automated Theorem Provers that use Formal Logic are - Vampire (Vampire, 2024) - E (The E Theorem Prover, 2024) - Z3 Theorem Prover (GitHub, The Z3 Theorem Prover, 2024)\nExamples of Automated Theorem Provers that use Type Theory are - LEAN (Programming Language and Theorem Prover - LEAN, 2024) - Coq (The Coq Proof Assistant, 2024) LEAN and Coq are not fully automated provers, but can be used to verify proofs and works as an computer assistant for mathematicians using it."
  },
  {
    "objectID": "blogs/posts/glorified-summery-Automated-Theorem-Provers/index.html#some-of-the-methods-for-proving",
    "href": "blogs/posts/glorified-summery-Automated-Theorem-Provers/index.html#some-of-the-methods-for-proving",
    "title": "Glorified Summery: Automated Theorem Provers",
    "section": "Some of the Methods for Proving",
    "text": "Some of the Methods for Proving\n\nProof by Refutation\nThe negation of the statement trying to be proved is appended to the set of axioms along with necessary assumptions, then checking if the resulting set of formulas is unsatisfiable. If it is, then the statement being proved is a logical consequence of the axioms and the assumptions. A proof of unsatisfiability of a negation of formula is sometimes called a refutation of this formula, so such proofs are commonly referred to as proofs by refutation.\nThe system appends the negation of the statement trying to be proved into the set of axioms, and applied rules of inferences on the axioms till it derives false. If we successfully end up deriving false, then the statement is indeed a consequence of the axioms.\n\nVampire using proof by Refutation algorithm in its provers. (Kovács, L. & Voronkov, A, 2013)\n\nResolution is a rule of inference leading to a refutation-complete theorem-proving technique for sentences in zeroth and first order logic. For propositional logic, systematically applying the resolution rule acts as a decision procedure for formula unsatisfiability, solving the (complement of the) Boolean satisfiability problem. (Wikipedia The Free Encyclopedia, Resolution (logic), 2024) Resolution rule of inference is stated as \\[(p \\lor q) \\land (\\lnot p \\lor q) \\implies q\\] SLD resolution (Selective Linear Definite clause resolution) is the basic inference rule used in logic programming. It is a refinement of resolution, which is both sound and refutation complete for Horn clauses. (Wikipedia The Free Encyclopedia, Selective Linear Definite clause resolution, 2024) #### Model Elimination The mnemonic label “model elimination” is used because the procedure seeks the truth-functionally contradictory statement associated with the procedures of creating new statements using the axioms by developing statements already “false” under some of the possible truth assignments over its atomic components. The procedure strives to form new statements which increase the percentage of the truth assignments yielding false for the statement. (Loveland, D.W. ,1968)\n\n\nMethod of Analytic Tableau\nAn analytic tableau is a tree structure computed for a logical formula, having at each node a sub-formula of the original formula to be proved or refuted. Computation constructs this tree and uses it to prove or refute the whole formula. The tableau method can also determine the satisfiability of finite sets of formulas of various logics. It is the most popular proof procedure for modal logics. A method of truth trees contains a fixed set of rules for producing trees from a given logical formula, or set of logical formulas. Those trees will have more formulas at each branch, and in some cases, a branch can come to contain both a formula and its negation, which is to say, a contradiction. In that case, the branch is said to close. If every branch in a tree closes, the tree itself is said to close. In virtue of the rules for construction of tableaux, a closed tree is a proof that the original formula, or set of formulas, used to construct it was itself self-contradictory, and therefore false. Conversely, a tableau can also prove that a logical formula is tautologous: if a formula is tautologous, its negation is a contradiction, so a tableau built from its negation will close (Colin Howson, 1997).\n\n\nQuantifier Elimination\nThe idea behind quantifier elimination is to rewrite the statements containing quantifiers into statements that do not contain any quantifiers. It is easier to deal with statements without quantifiers, proving such statements is an easier task. Informally, a quantified statement “\\(\\forall x\\) such that \\(…\\)” can be viewed as a question “When is there an \\(x\\) such that \\(…\\) ?”, and the statement without quantifiers can be viewed as the answer to that question (Wikipedia The Free Encyclopedia, Quantifier elimination, 2024). For example, the statement “quadratic polynomial has a real root if and only if its discriminant is non-negative” can be represented as \\[\\exists x \\in R . (a \\neq 0 \\land ax^2 +bx + c = 0)\\] using quantifiers, and \\[a \\neq 0 \\land b^2 -4ac &gt; 0\\] without any quantifiers.\nSimilar idea can be applied when statements are represented in higher order logic. Statements in higher order logic can be transformed or reduced into simpler statements of first order logic. (Manfred Kerber. 1991)\n\n\nSMT Solvers\nThere is substantial overlap between first-order automated theorem provers and SMT (# Satisfiability Modulo Theories) solvers and Boolean satisfiability problem. Generally, automated theorem provers focus on supporting full first-order logic with quantifiers, whereas SMT solvers focus more on supporting various theories (interpreted predicate symbols). Automated Theorem Provers excel at problems with lots of quantifiers, whereas SMT solvers do well on large problems without quantifiers. (Wikipedia The Free Encyclopedia, Satisfiability modulo theories, 2024)"
  },
  {
    "objectID": "blogs/posts/glorified-summery-Automated-Theorem-Provers/index.html#discoveries-using-automated-theorem-provers",
    "href": "blogs/posts/glorified-summery-Automated-Theorem-Provers/index.html#discoveries-using-automated-theorem-provers",
    "title": "Glorified Summery: Automated Theorem Provers",
    "section": "Discoveries using Automated Theorem Provers",
    "text": "Discoveries using Automated Theorem Provers\n\nRobbins Conjecture\nRobbins algebra is an algebra containing a single binary operation, usually denoted by \\(\\lor\\) (or), and a single unary operation usually denoted by \\(\\lnot\\) (not) satisfying the following axioms: for all \\(a\\), \\(b\\) & \\(c\\) - Associativity: \\(a \\lor (b \\lor c) = (a \\lor b) \\lor c\\) - Commutativity: \\(a \\lor b = b \\lor a\\) - Robbins equation: \\(\\lnot (\\lnot (a \\lor b) \\lor \\lnot (a \\lor \\lnot b)) = a\\) For many years, it was conjectured, but unproven, that all Robbins algebras are Boolean algebras. (Robbins Algebras Are Boolean, 2024) William McCune proved the conjecture in 1996, using the automated theorem prover EQP (EQP: Equational Theorem Prover, 2024).\n\n\nFour Colour Theorem\nThe four colour theorem, or the four colour map theorem, states that no more than four colours are required to colour the regions of any map so that no two adjacent regions have the same colour. The theorem is a stronger version of the five color theorem, which can be shown using a significantly simpler argument. Although the weaker five color theorem was proven already in the 1800s, the four color theorem resisted until 1976 when it was proven by Kenneth Appel and Wolfgang Haken. The Appel-Haken proof proceeds by analyzing a very large number of reducible configurations. This was improved upon in 1997 by Robertson, Sanders, Seymour, and Thomas who have managed to decrease the number of such configurations to 633 – still an extremely long case analysis. In 2005, the theorem was verified by Georges Gonthier using a general-purpose theorem-proving software. (K. Appel. W. Haken, 1977)\n\n\nFormalisation of Fermat’s Last Theorem\nFermat’s Last Theorem states that no three positive integers \\(a\\), \\(b\\), and \\(c\\) satisfy the equation \\(a^n + b^n = c^n\\) for any integer value of \\(n\\) greater than 2. The cases \\(n = 1\\) and \\(n = 2\\) have been known since antiquity to have infinitely many solutions. The proposition was first stated as a theorem by Pierre de Fermat around 1637 in the margin of a copy of Arithmetica. After 358 years of effort by mathematicians, the first successful proof was released in 1994 by Andrew Wiles and formally published in 1995. The Fermat’s Last Theorem Project is a project to formalise the entire proof of Fermat’s Last Theorem. The project is an open project, where anyone could contribute. The LEAN programming language which is also a proof assist-er is used for this process of formalisation. The project is hosted on GitHub. The proof depends on multiple areas of mathematics and the current database of theorems in LEAN is inadequate. The project intends to formalise multiple branches of mathematics over next couple of years. The project will be funded by Engineering & Physical Sciences Research Council for the first 5 years. (The Fermat’s Last Theorem Project, Lean community blog, 2024)"
  },
  {
    "objectID": "blogs/posts/glorified-summery-Automated-Theorem-Provers/index.html#limitation",
    "href": "blogs/posts/glorified-summery-Automated-Theorem-Provers/index.html#limitation",
    "title": "Glorified Summery: Automated Theorem Provers",
    "section": "Limitation",
    "text": "Limitation\nDefinitions\nCompleteness: A formal theory (that is rules of inference and starting set of axioms) is said to be complete if we can prove or prove the negation of any statement that can be expressed in that system. Consistent: A formal theory is said to be consistent if it is free of contradictions. That is, the theory should not be able to prove a statement and also it negation. In such a system, it is possible to prove any and all statements to be true statement. Decidable: A formal theory is said to be decidable if there exists an algorithm that takes in a statement in the system as its input and returns true or false depending on if the statement is true under the theory or false.\nDavid Hilbert wanted to come up with a formal theory of mathematics that is complete, consistent and decidable, and could express entirety of mathematics. (Stanford Encyclopedia of Philosophy Archive, Hilbert’s Program, 2024)\nGödel’s incompleteness theorems by Kurt Gödel, showed that any system complex enough to do arithmetic on natural numbers cannot be complete, consistent and decidable at the same time. (Kurt Gödel, 1931)\nThe first incompleteness theorem states that no consistent system of axioms whose theorems can be listed by an effective procedure (i.e. an algorithm) is capable of proving all truths about the arithmetic of natural numbers. For any such consistent formal system, there will always be statements about natural numbers that are true, but that are unprovable within the system.\nThe second incompleteness theorem, shows that no system can demonstrate its own consistency, i.e. a system cannot prove that it is itself free of contradictions.\nAlan Turing showed that having a decidable algorithm is equivalent to solving the halting problem. (Alan Turing, 1936)"
  },
  {
    "objectID": "blogs/posts/glorified-summery-Automated-Theorem-Provers/index.html#example-usage",
    "href": "blogs/posts/glorified-summery-Automated-Theorem-Provers/index.html#example-usage",
    "title": "Glorified Summery: Automated Theorem Provers",
    "section": "Example Usage",
    "text": "Example Usage\n\nSolving a exercise problem from Discrete Mathematics Textbook\nProblem Statement: Determine whether this argument is valid: If Superman were able and willing to prevent evil, he would do so. If Superman were unable to prevent evil, he would be impotent; if he were unwilling to prevent evil, he would be malevolent. Superman does not prevent evil. If Superman exists, he is neither impotent nor malevolent. Therefore, Superman does not exist. (Kenneth Rosen, 2011)\nThe problem can be solved using zeroth order logic (propositional logic). We first need to represent the question in notations of formal logic.\nLet the following be constant symbols representing an atomic statement from the problem statement \\(a\\): “Superman is able to prevent evil” \\(b\\): “Superman is willing to prevent evil” \\(c\\): “Superman is impotent” \\(d\\): “Superman is malevolent” \\(e\\): “Superman prevents evil” \\(f\\): “Superman exists” Now, the assumptions or the axioms can be written as follows: \\((a \\land b) \\to e\\): “If Superman were able and willing to prevent evil, he would do so” \\(\\lnot e \\to c\\): “If Superman were unable to prevent evil, he would be impotent” \\(\\lnot b \\to d\\): “if he were unwilling to prevent evil, he would be malevolent” \\(\\lnot e\\): “Superman does not prevent evil.” \\(f \\to (\\lnot c \\land \\lnot d)\\): “If Superman exists, he is neither impotent nor malevolent” And the conclusion would be: \\(\\lnot f\\): “Superman does not exist”\n\nSolving using Vampire\nVampire uses TPTP (TPTP, 2024) syntax to represent mathematical statements. The above mathematical statements will be written as:\nfof(id1, axiom,\n(a & b) =&gt; e).\n\nfof(id2, axiom,\n~e =&gt; c).\n\nfof(id3, axiom,\n~b =&gt; d).\n\nfof(id4, axiom,\n~e).\n\nfof(id5, axiom,\nf =&gt; (~c & ~d)).\n\nfof(res, conjecture, ~f).\nAnd running Vampire on the above\n...\n% Refutation found. Thanks to Tanya!\n% SZS status Theorem for superman\n% SZS output start Proof for superman\n2. ~e =&gt; c [input]\n4. ~e [input]\n5. f =&gt; (~d & ~c) [input]\n6. ~f [input]\n7. ~~f [negated conjecture 6]\n8. f [flattening 7]\n11. f =&gt; ~c [pure predicate removal 5]\n12. c | e [ennf transformation 2]\n13. ~c | ~f [ennf transformation 11]\n14. c | e [cnf transformation 12]\n15. ~e [cnf transformation 4]\n16. ~c | ~f [cnf transformation 13]\n17. f [cnf transformation 8]\n19. 1 &lt;=&gt; e [avatar definition]\n23. 2 &lt;=&gt; c [avatar definition]\n26. 1 | 2 [avatar split clause 14,23,19]\n27. ~1 [avatar split clause 15,19]\n29. 3 &lt;=&gt; f [avatar definition]\n32. ~3 | ~2 [avatar split clause 16,23,29]\n33. 3 [avatar split clause 17,29]\n34. $false [avatar sat refutation 26,27,32,33]\n% SZS output end Proof for superman\n...\n\n\nSolving using logic\nLogic is a python library written by Vipul Cariappa (GitHub, Logic, 2024), that uses rules of inference to construct the proof. Logic presently only works with zeroth order logic, therefore can be applied in this case. But the algorithm used is not complete.\nfrom logic import Proposition, IMPLY, prove\n\n\n# Creating propositional variables\na = Proposition(\"a\") # \"Superman is able to prevent evil\"\nb = Proposition(\"b\") # \"Superman is willing to prevent evil\"\nc = Proposition(\"c\") # \"Superman is impotent\"\nd = Proposition(\"d\") # \"Superman is malevolent\"\ne = Proposition(\"e\") # \"Superman prevents evil\"\nf = Proposition(\"f\") # \"Superman exists\"\n\n# encoding assumptions\nassumptions = [\n    IMPLY(a & b, e),\n    IMPLY(~e, c),\n    IMPLY(~b, d),\n    ~e,\n    IMPLY(f, ~c & ~d),\n]\n\n# encoding conclusion\nconclusion = ~f\n\n# printing assumptions\nprint(\"Assumptions:\")\nfor i in assumptions:\n    print(i)\n\n# printing conclusion\nprint(f\"Conclusion: {conclusion}\")\n\n# generating proof\nproof, truth = prove(assumptions, conclusion)\nassert truth == True # checking if it could be proved\n\n# printing proof\nprint(proof)\nOutput:\nAssumptions:\n(((a ∧ b)) → (e))\n((¬ (e)) → (c))\n((¬ (b)) → (d))\n¬ (e)\n((f) → ((¬ (c) ∧ ¬ (d))))\nConclusion: ¬ (f)\n                           c                 Modus Ponens {((¬ (e)) → (c)), ¬ (e)}    \n                   ¬ (¬ (c))                   Not Of Not {c}                         \n     (¬ (¬ (c)) ∨ ¬ (¬ (d)))                     Addition {¬ (¬ (c)), ¬ (¬ (d))}      \n         ¬ ((¬ (c) ∧ ¬ (d)))              De'Morgen's Law {(¬ (¬ (c)) ∨ ¬ (¬ (d)))}   \n                       ¬ (f)                Modus Tollens {((f) → ((¬ (c) ∧ ¬ (d)))), ¬ ((¬ (c) ∧ ¬ (d)))}\n\n\n\nUsing Predicates in Vampire\nEncoding arithmetic over natural number using Peano Axioms (Wikipedia The Free Encyclopedia, Peano Axioms, 2024) to prove \\(2 = 1 + 1\\)\nfof(\n    identity_add,\n    axiom,\n    ! [X] : add(X, zero) = X\n).\n\nfof(\n    identity_mul,\n    axiom,\n    ! [X] : mul(X, zero) = zero\n).\n\nfof(\n    op_add,\n    axiom,\n    ! [X, Y] : add(X, succ(Y)) = succ(add(X, Y))\n).\n\nfof(\n    op_mul,\n    axiom,\n    ! [X, Y] : mul(X, succ(Y)) = add(X, mul(X, Y))\n).\n\nfof(\n    successor,\n    axiom,\n    ! [X, Y] : (succ(X) = succ(Y)) =&gt; (X = Y)\n).\n\nfof(\n    successor_neq_zero,\n    axiom,\n    ! [X] : ~(succ(X) = zero)\n).\n\nfof(\n    two_eqs_one_plus_one,\n    conjecture,\n    succ(succ(zero)) = add(succ(zero), succ(zero))\n).\nOutput\n...\n% Refutation found. Thanks to Tanya!\n% SZS status Theorem for peano\n% SZS output start Proof for peano\n1. ! [X0] : add(X0,zero) = X0 [input]\n3. ! [X0,X1] : add(X0,succ(X1)) = succ(add(X0,X1)) [input]\n7. succ(succ(zero)) = add(succ(zero),succ(zero)) [input]\n8. ~succ(succ(zero)) = add(succ(zero),succ(zero)) [negated conjecture 7]\n11. succ(succ(zero)) != add(succ(zero),succ(zero)) [flattening 8]\n16. add(X0,zero) = X0 [cnf transformation 1]\n18. add(X0,succ(X1)) = succ(add(X0,X1)) [cnf transformation 3]\n22. succ(succ(zero)) != add(succ(zero),succ(zero)) [cnf transformation 11]\n31. succ(succ(zero)) != succ(add(succ(zero),zero)) [superposition 22,18]\n32. succ(succ(zero)) != succ(succ(zero)) [forward demodulation 31,16]\n33. $false [trivial inequality removal 32]\n% SZS output end Proof for peano\n...\n\nUsing LEAN to prove sum of two even numbers is even\nLEAN is based on Type Theory. LEAN does not provide a proof, but is a interactive proof assistant, that can detect errors in proof and can verify the proof. If the LEAN compiler does not give any error it means that the proof is a valid proof. The proof of sum of two even numbers is even in LEAN looks as follows:\ndef is_even (a : Nat) := ∃ b, a = 2 * b\n\ntheorem even_plus_even (h1 : is_even a) (h2 : is_even b) : is_even (a + b) :=\n  Exists.elim h1 (fun w1 (hw1 : a = 2 * w1) =&gt;\n  Exists.elim h2 (fun w2 (hw2 : b = 2 * w2) =&gt;\n    Exists.intro (w1 + w2)\n      (calc a + b\n        _ = 2 * w1 + 2 * w2 := by rw [hw1, hw2]\n        _ = 2 * (w1 + w2)   := by rw [Nat.mul_add])))"
  },
  {
    "objectID": "blogs/posts/glorified-summery-Automated-Theorem-Provers/index.html#conclusion",
    "href": "blogs/posts/glorified-summery-Automated-Theorem-Provers/index.html#conclusion",
    "title": "Glorified Summery: Automated Theorem Provers",
    "section": "Conclusion",
    "text": "Conclusion\nAutomated theorem provers have significantly advanced the landscape of mathematical proof verification and generation. By leveraging formal logic, type theory, and various inference techniques, automated theorem provers offer robust tools for tackling complex mathematical problems. The development of systems like Vampire, E, Z3, LEAN, and Coq exemplifies the diverse approaches and strengths within the field. Notable achievements, such as the resolution of the Robbins Conjecture and the formal verification of the Four Colour Theorem and formalisation of Fermat’s Last Theorem, highlight the practical and theoretical impact of these technologies. As automated theorem provers continue to evolve, their integration with modern computational frameworks promises to further enhance their efficiency and applicability, paving the way for new discoveries and the formalisation of more complex mathematical theories."
  },
  {
    "objectID": "blogs/posts/glorified-summery-Automated-Theorem-Provers/index.html#references",
    "href": "blogs/posts/glorified-summery-Automated-Theorem-Provers/index.html#references",
    "title": "Glorified Summery: Automated Theorem Provers",
    "section": "References",
    "text": "References\n\nWikipedia The Free Encyclopedia, First Order Logic, viewed 17th July 2024, (https://en.wikipedia.org/wiki/First-order_logic)\nWikipedia The Free Encyclopedia, Propositional calculus, viewed 17th July 2024, (https://en.wikipedia.org/wiki/Propositional_logic)\nWikipedia The Free Encyclopedia, Higher-Order Logic, viewed 17th July 2024, (https://en.wikipedia.org/wiki/Higher-order_logic)\nWikipedia The Free Encyclopedia, Type Theory, viewed 17th July 2024, (https://en.wikipedia.org/wiki/Type_theory)\nHelmut Brandl, 2024, Typed Lambda Calculus / Calculus of Constructions\nHall, J. G., ed. Intuitionistic Type Theory: Notes by Giovanni Sambin of a series of lectures given in Padova, June 1980. By Per Martin-Löf (1980). Digital Edition (2021).\nWikipedia The Free Encyclopedia, Rules of Inference, viewed 17th July 2024, (https://en.wikipedia.org/wiki/Rule_of_inference)\nVampire, viewed 17th July 2024, (https://vprover.github.io/index.html)\nThe E Theorem Prover, viewed 17th July 2024, (https://wwwlehre.dhbw-stuttgart.de/~sschulz/E/E.html)\nGitHub, The Z3 Theorem Prover, viewed 17th July 2024, (https://github.com/Z3Prover/z3)\nProgramming Language and Theorem Prover - LEAN, viewed 17th July 2024, (https://lean-lang.org/)\nThe Coq Proof Assistant, viewed 17th July 2024, (https://coq.inria.fr/)\nKovács, L. & Voronkov, A. (2013). First-Order Theorem Proving and Vampire . In: Sharygina, N., Veith, H. (eds) Computer Aided Verification. CAV 2013. Lecture Notes in Computer Science, vol 8044. Springer, Berlin, Heidelberg, (https://doi.org/10.1007/978-3-642-39799-8_1)\nWikipedia The Free Encyclopedia, Resolution (logic), viewed 17th July 2024, (https://en.wikipedia.org/wiki/First-order_resolution)\nLoveland, D.W. (1968). Mechanical Theorem-Proving by Model Elimination. In: Siekmann, J.H., Wrightson, G. (eds) Automation of Reasoning. Symbolic Computation. Springer, Berlin, Heidelberg, (https://doi.org/10.1007/978-3-642-81955-1_8)\nColin Howson, Logic with Trees, An Introduction to Symbolic Logic, 1997 http://ndl.ethernet.edu.et/bitstream/123456789/77275/1/29.pdf\nWikipedia The Free Encyclopedia, Quantifier elimination, viewed 17th July 2024, (https://en.wikipedia.org/wiki/Quantifier_elimination)\nManfred Kerber. 1991. How to prove higher order theorems in first order logic. In Proceedings of the 12th international joint conference on Artificial intelligence - Volume 1 (IJCAI’91). Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 137–142.\nWikipedia The Free Encyclopedia, Satisfiability modulo theories, viewed 17th July 2024, (https://en.wikipedia.org/wiki/Satisfiability_modulo_theories)\nWikipedia The Free Encyclopedia, Selective Linear Definite clause resolution, viewed 17th July 2024, (https://en.wikipedia.org/wiki/SLD_resolution)\nThe Fermat’s Last Theorem Project, Lean community blog, viewed 17th July 2024, (https://leanprover-community.github.io/blog/posts/FLT-announcement/)\nEQP: Equational Theorem Prover, viewed 17th July 2024, (https://www.cs.unm.edu/~mccune/eqp/)\nRobbins Algebras Are Boolean, viewed 17th July 2024, (https://www.cs.unm.edu/~mccune/papers/robbins/)\nK. Appel. W. Haken. “Every planar map is four colorable. Part I: Discharging.” Illinois J. Math. 21 (3) 429 - 490, September 1977. https://doi.org/10.1215/ijm/1256049011\nKenneth Rosen, Discrete Mathematics and Its Applications, McGraw-Hill Education, 2011\nTPTP, viewed 17th July 2024, (https://www.tptp.org/)\nGitHub, Logic, Vipul-Cariappa, viewed 17th July 2024, (https://github.com/Vipul-Cariappa/logic)\nWikipedia The Free Encyclopedia, Peano Axioms, viewed 17th July 2024, (https://en.wikipedia.org/wiki/Peano_axioms)\nAlan Turing, “On Computable Numbers, With An Application To The Entscheidungsproblem”\nStanford Encyclopedia of Philosophy Archive, Hilbert’s Program, viewed 17th July 2024, (https://plato.stanford.edu/archives/spr2023/entries/hilbert-program)\nKurt Gödel, On Formally Undecidable Propositions of Principia Mathematica and Related Systems I"
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Week-10-and-11/index.html",
    "href": "blogs/posts/GSoC'24-LPython-Week-10-and-11/index.html",
    "title": "GSoC’24 - LPython: 10th & 11th Week",
    "section": "",
    "text": "The last two weeks were slow. But implemented very important features. I am currently busy with my college examinations, and could not give much time here.\nI have implemneted ASR pass for BindPython ABI. BindPython ABI allows calling into CPython code from LPython. Previously BindPython was exclusively implemented on the C backend. The advantage of implementing the ASR pass for BindPython is that all the backends will support out of the box, provided it already supports BindC ABI. Most if not all backends already support BindC ABI. The pass generates the body of the declared BindPython function. The pass takes care of the necessary type conversions from the CPython type to the native type and from the native type to the CPython type. The pass also takes care of loading the CPython module and getting a reference to the function that needs to be called.\nType conversions of primitive types (i.e. int, float, bool, and str) have been implemented and merged. I have an open PR for type conversions of aggregate type (i.e. list, tuple, dict, and set).\nThe previous implementation of BindPython ABI in the C backend conversions LPython arrays into numpy arrays and passing numpy arrays to CPython functions. In the coming week, I will be working on conversions of LPython arrays to numpy arrays for the same."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Week-10-and-11/index.html#merged-pull-request",
    "href": "blogs/posts/GSoC'24-LPython-Week-10-and-11/index.html#merged-pull-request",
    "title": "GSoC’24 - LPython: 10th & 11th Week",
    "section": "Merged Pull Request",
    "text": "Merged Pull Request\n\nBindPython ABI Support to call into CPython from LPython. Primitive types."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Week-10-and-11/index.html#open-pull-request",
    "href": "blogs/posts/GSoC'24-LPython-Week-10-and-11/index.html#open-pull-request",
    "title": "GSoC’24 - LPython: 10th & 11th Week",
    "section": "Open Pull Request",
    "text": "Open Pull Request\n\nBindPython ASR Pass: aggregate type conversions Type conversions of list, tuple, dict, and set between CPython types and LPython types. To support calling CPython functions from LPython."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Vipul Cariappa",
    "section": "",
    "text": "I am a student at Ramaiah University of Applied Sciences, Bangalore, pursuing my B.Tech in Computer Science and Engineering. I love to program and write code. Presently my programming interests are programming languages, their design and implementations. My interests keep changing as I am still exploring the vastness of computer science. Computational mathematics is something which has caught my eyes recently. I am very much fond of open source technologies and love to contribute. I am trying to learn, explore and spread my findings to others.\nMy hobbies and other interests include mathematics, swimming, eating and playing lots of video games."
  },
  {
    "objectID": "blogs/index.html",
    "href": "blogs/index.html",
    "title": "Blogs",
    "section": "",
    "text": "Glorified Summery: Automated Theorem Provers\n\n\n\n\n\n\nMath\n\n\nLogic\n\n\n\n\n\n\n\n\n\nOct 8, 2024\n\n\nVipul Cariappa, Ravi Kamath\n\n\n\n\n\n\n\n\n\n\n\n\nGSoC’24 - LPython: Project Completion\n\n\n\n\n\n\nGSoC\n\n\nCode\n\n\nInternship\n\n\nPython\n\n\nLPython\n\n\n\n\n\n\n\n\n\nAug 25, 2024\n\n\nVipul Cariappa\n\n\n\n\n\n\n\n\n\n\n\n\nGSoC’24 - LPython: 10th & 11th Week\n\n\n\n\n\n\nGSoC\n\n\nCode\n\n\nInternship\n\n\nPython\n\n\nLPython\n\n\n\n\n\n\n\n\n\nAug 18, 2024\n\n\nVipul Cariappa\n\n\n\n\n\n\n\n\n\n\n\n\nGSoC’24 - LPython: 8th & 9th Week\n\n\n\n\n\n\nGSoC\n\n\nCode\n\n\nInternship\n\n\nPython\n\n\nLPython\n\n\n\n\n\n\n\n\n\nJul 27, 2024\n\n\nVipul Cariappa\n\n\n\n\n\n\n\n\n\n\n\n\nGSoC’24 - LPython: 7th Week\n\n\n\n\n\n\nGSoC\n\n\nCode\n\n\nInternship\n\n\nPython\n\n\nLPython\n\n\n\n\n\n\n\n\n\nJul 13, 2024\n\n\nVipul Cariappa\n\n\n\n\n\n\n\n\n\n\n\n\nGSoC’24 - LPython: 6th Week\n\n\n\n\n\n\nGSoC\n\n\nCode\n\n\nInternship\n\n\nPython\n\n\nLPython\n\n\n\n\n\n\n\n\n\nJul 6, 2024\n\n\nVipul Cariappa\n\n\n\n\n\n\n\n\n\n\n\n\nGSoC’24 - LPython: 4th & 5th Week\n\n\n\n\n\n\nGSoC\n\n\nCode\n\n\nInternship\n\n\nPython\n\n\nLPython\n\n\n\n\n\n\n\n\n\nJun 29, 2024\n\n\nVipul Cariappa\n\n\n\n\n\n\n\n\n\n\n\n\nGSoC’24 - LPython: Third Week\n\n\n\n\n\n\nGSoC\n\n\nCode\n\n\nInternship\n\n\nPython\n\n\nLPython\n\n\n\n\n\n\n\n\n\nJun 15, 2024\n\n\nVipul Cariappa\n\n\n\n\n\n\n\n\n\n\n\n\nGSoC’24 - LPython: First Two Week\n\n\n\n\n\n\nGSoC\n\n\nCode\n\n\nInternship\n\n\nPython\n\n\nLPython\n\n\n\n\n\n\n\n\n\nJun 7, 2024\n\n\nVipul Cariappa\n\n\n\n\n\n\n\n\n\n\n\n\nGoogle Summer of Code 2024 - My Project\n\n\n\n\n\n\nGSoC\n\n\nCode\n\n\nInternship\n\n\nPython\n\n\nLPython\n\n\n\n\n\n\n\n\n\nMay 23, 2024\n\n\nVipul Cariappa\n\n\n\n\n\n\n\n\n\n\n\n\nGSoC’23 - GNU Octave: Project Completion\n\n\n\n\n\n\nGSoC\n\n\nCode\n\n\nInternship\n\n\nGNU Octave\n\n\n\n\n\n\n\n\n\nAug 27, 2023\n\n\nVipul Cariappa\n\n\n\n\n\n\n\n\n\n\n\n\nGSoC’23 - GNU Octave: First 5 Weeks\n\n\n\n\n\n\nGSoC\n\n\nCode\n\n\nInternship\n\n\nGNU Octave\n\n\n\n\n\n\n\n\n\nJul 9, 2023\n\n\nVipul Cariappa\n\n\n\n\n\n\n\n\n\n\n\n\nGSoC’23 - GNU Octave: Week 1\n\n\n\n\n\n\nGSoC\n\n\nCode\n\n\nInternship\n\n\nGNU Octave\n\n\n\n\n\n\n\n\n\nJun 4, 2023\n\n\nVipul Cariappa\n\n\n\n\n\n\n\n\n\n\n\n\nGoogle Summer of Code 2023 - My Project\n\n\n\n\n\n\nGSoC\n\n\nCode\n\n\nInternship\n\n\nGNU Octave\n\n\n\n\n\n\n\n\n\nMay 6, 2023\n\n\nVipul Cariappa\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "blogs/posts/GSoC'23-GNU-Octave-First-Five-Weeks/index.html",
    "href": "blogs/posts/GSoC'23-GNU-Octave-First-Five-Weeks/index.html",
    "title": "GSoC’23 - GNU Octave: First 5 Weeks",
    "section": "",
    "text": "This is an account of all the tasks that I am finished with from the start of GSoC, or am working on at the moment."
  },
  {
    "objectID": "blogs/posts/GSoC'23-GNU-Octave-First-Five-Weeks/index.html#completed-tasks",
    "href": "blogs/posts/GSoC'23-GNU-Octave-First-Five-Weeks/index.html#completed-tasks",
    "title": "GSoC’23 - GNU Octave: First 5 Weeks",
    "section": "Completed Tasks",
    "text": "Completed Tasks\n\nMoved the repository which was previously hosted by a single person to hosting it under the GNU Octave project at GitLab. Work on this front was mainly done by my mentor Colin. Link to the repository at GitLab: GNU Octave / Octave Pythonic.\nSupporting the latest versions of Python in Pythonic. Pythonic previously only supported Python version 3.9 and below. Now Pythonic supports the latest version of Python which is Python 3.11. Link to Merged MR at GitLab: Support python 3.10 & 3.11 and drops support for less then 3.7.\nUsing Python Stable ABI in Pythonic to support multiple versions of Python. Pythonic now uses Python Stable ABI. Python Stable ABI is a limited subset of the Python C API which Python Organisation grantees to be backward and forward compatible with old and new versions of Python. Link to Merged MR at GitLab: Updating Pythonic to use Python Stable ABI.\nUpdating the CI/CD pipeline at GitLab to test Pythonic against multiple versions of Python and Octave. In this update, we also migrated to use the official Docker image for Octave provided by GNU Octave. Now our automated CI/CD testing, tests Pythonic with the latest version of Octave which is version 8.2 with all the supported Python versions i.e. from Python version 3.7 to 3.11. It also tests Octave 7.1 with Python 3.9 and Octave 6.1 with Python 3.10. The CI/CD pipeline updates I am talking about at this point are restricted to testing on Linux. For testing on other platforms read the sections below. Link to Merged MR at GitLab: Updating gitlab CI/CD to use official gnu octave docker image.\nProvide proof of concept of pyimport. pyimport is a command to import Python functions, classes, namespaces, or any other symbols into the Octave workspace. The concept is appreciated, but may not be merged into the main branch as it is a workaround to the fact that function handles are not yet supported on Pythonic. Link to Merge Request at GitLab: Add support to import modules using pyimport command.\nUpdated the Pythonic wiki with a list of functions and class methods Pythonic offers. Link to the wiki: Pythonic/fullAPI."
  },
  {
    "objectID": "blogs/posts/GSoC'23-GNU-Octave-First-Five-Weeks/index.html#on-going-work",
    "href": "blogs/posts/GSoC'23-GNU-Octave-First-Five-Weeks/index.html#on-going-work",
    "title": "GSoC’23 - GNU Octave: First 5 Weeks",
    "section": "On Going Work",
    "text": "On Going Work\n\nImplementation of destructor for pyobjects Destructor was previously not supported on Pythonic. Variables which were no longer used were still kept in memory and were not freed/released from memory. This was due to a bug in the core Octave interpreter (bug #46497, classdef: delete destructor method…). This bug is now fixed. Link to Merge Request at GitLab: Support for destructor of pyobject.\nImplementation of pyenv function pyenv is a MATLAB compatibility function. pyenv lets the user select the version of Python to be used. At the time of writing this article, the pyenv functionality is working properly on Linux systems, but using it on Windows crashes Octave. To me, it looks like an issue with how Octave is packaged on Windows. Because depending on how Octave is launched the functionality works or does not work. Any progress on this will be appended to this article later. Link to Merge Request at GitLab: pyenv function to select python version.\nTesting on Windows (and MacOS) I am primarily focusing on Windows. My mentor is currently looking at MacOS. Octave does not offer a Windows Docker image to test on Windows. Compiling any octave package which contains C/C++ code required some Linux specific tools to be installed (at least in the case of Pythonic), which is usually bundled with Octave on Windows. But compiling Pythonic on GitLab’s CI/CD pipeline has been a work with no success till now. Link to Merge Request on Gitlab: CI: Build / Test on Windows."
  },
  {
    "objectID": "blogs/posts/GSoC'23-GNU-Octave-First-Five-Weeks/index.html#issues-discussions-i-opened",
    "href": "blogs/posts/GSoC'23-GNU-Octave-First-Five-Weeks/index.html#issues-discussions-i-opened",
    "title": "GSoC’23 - GNU Octave: First 5 Weeks",
    "section": "Issues / Discussions I Opened",
    "text": "Issues / Discussions I Opened\n\nA test fails on Windows (when trying it out on my local machine). This is mostly due to an integer overflow. Link to the Issue at GitLab: A test fails on Windows.\nErrors/Issues I encounter when working on Windows. Links to Discussion at Discourse: How to compile Octave in Windows? and Mkoctfile does not work on windows."
  },
  {
    "objectID": "blogs/posts/GSoC'23-GNU-Octave-First-Five-Weeks/index.html#miscellaneous",
    "href": "blogs/posts/GSoC'23-GNU-Octave-First-Five-Weeks/index.html#miscellaneous",
    "title": "GSoC’23 - GNU Octave: First 5 Weeks",
    "section": "Miscellaneous",
    "text": "Miscellaneous\n\nIssues or discussions I opened or any other contributions to the GNU Octave which do not directly concern my GSoC project.\n\n\nOpened topic on Discourse on a bug., which shows the wrong link of packages. Link to the Discussion at Discourse: Wrong link shown in the Community topics related to the release of a package.\nBug report filed: “panic: impossible state reached” while using subsasgn with struct and multiple subs value and Octave crashes while saving data to file.\nWork on supporting HDF5 file format: Ongoing Implementing h5disp; Merged Implemented: test runner script and gihub action to run tests and Implemented H5A.get_num_attrs."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Week-3/index.html",
    "href": "blogs/posts/GSoC'24-LPython-Week-3/index.html",
    "title": "GSoC’24 - LPython: Third Week",
    "section": "",
    "text": "This week was a slow week. I am stuck with a design decision regarding the implementation of printing top-level expressions when the expression is an aggregate datatype like list, tuple, dict, set or user defined classes."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Week-3/index.html#problem-i-am-stuck-at",
    "href": "blogs/posts/GSoC'24-LPython-Week-3/index.html#problem-i-am-stuck-at",
    "title": "GSoC’24 - LPython: Third Week",
    "section": "Problem I am stuck at",
    "text": "Problem I am stuck at\nI have implemented this printing of top-level expression for primitive datatypes, i.e. i8, u8, …, float, double, bool, and str. Presently the way it works; We collect all the top-level expressions into a global_stmts function using the global_stmts ASR pass. The global_stmts function returns the last evaluated expression. We parse each REPL code block and construct this global_stmts function and call it and get its return value. Then print it externally. We use the same approach in LFortran.\nI am facing a problem now. I am not able to come up with a good way to implement the printing of top-level expressions for aggregate datatypes, like list, dict, set, tuple and user-defined classes.\nLet’s consider list for now. The following LPython code x: list[i32] is represent as following in LLVM IR:\n%list = type { i32, i32, i32* }\n\n@x = global %list zeroinitializer\nand if we want to return it from a function our function signature in LLVM IR looks like\ndeclare %list @__main__global_stmts_2__()\nWe presently call the global_stmts function and get its return type through e-&gt;execfn&lt;return_type&gt;(function_name). For the above mentioned case of list what would our return_type be? What will we cast it into?\nIf we consider the case of tuple it becomes even more complicated. Below is the LLVM IR for different tuple declarations: t1: tuple[i32] -&gt; %tuple = type { i32 } t2: tuple[i32, i32] -&gt; %tuple.0 = type { i32, i32 } t3: tuple[i32, i32, str] -&gt; %tuple.1 = type { i32, i32, i8* }\nAnd if we have a user-defined class in the mix it will become increasingly more complex.\nIn case of list[i32] we could do\ntypedef struct {int32_t s; int32_t c; int32_t* b;} List_i32;\ne-&gt;execfn&lt;List_i32&gt;(run_fn);\nBut we will not be able to do anything when it comes to a tuple, the TYPE in e-&gt;execfn&lt;TYPE&gt;(run_fn) should be known at compile time (i.e. compile time of the LPython compiler itself).\nI have posted an message regarding this on Zulip.\n\nAs I was stuck with the above problem, I did some research on the other things I will be concentrating on in the future; Redefinition of symbols. I went through LLVM’s documentation on how would we implement the ability to redefine symbols. If each symbol is constructed into an independent LLVMModule and we associate each LLVMModule with a ResourceTracker then we could call the destructor for the ResourceTracker when we want to redefine a symbol, resulting in the deletion of the old definition."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Week-3/index.html#merged-pull-requests",
    "href": "blogs/posts/GSoC'24-LPython-Week-3/index.html#merged-pull-requests",
    "title": "GSoC’24 - LPython: Third Week",
    "section": "Merged Pull Requests",
    "text": "Merged Pull Requests\n\ncombining duplicated function into a single templated function (In LFortran) We previously had separate functions for each primitive datatype that called into LLVM’s JIT compiled function, they were combined into a template based function. The same changes were also made in LPython.\nImproved CLI experience for REPL Ability you use arrow keys to get history and the ability to make edits in REPL.\nsupport printing boolean in REPL Support to print boolean datatypes in REPL."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Week-3/index.html#open-pull-requests",
    "href": "blogs/posts/GSoC'24-LPython-Week-3/index.html#open-pull-requests",
    "title": "GSoC’24 - LPython: Third Week",
    "section": "Open Pull Requests",
    "text": "Open Pull Requests\n\nfix array symbol duplication in interactive mode This PR fixed a bug in which array symbols would be duplicated for each REPL evaluation loop.\n\n\nI will be taking the next week off, as I am having my college examination. I will start back work from 23th June."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Week-8-and-9/index.html",
    "href": "blogs/posts/GSoC'24-LPython-Week-8-and-9/index.html",
    "title": "GSoC’24 - LPython: 8th & 9th Week",
    "section": "",
    "text": "The last two weeks were slow. I was busy with college work and could not give sufficient time for GSoC. Due to this, I could not write the last week’s blog. I should be relatively free next week, hope everything goes smoothly."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Week-8-and-9/index.html#merged-pull-requests",
    "href": "blogs/posts/GSoC'24-LPython-Week-8-and-9/index.html#merged-pull-requests",
    "title": "GSoC’24 - LPython: 8th & 9th Week",
    "section": "Merged Pull Requests",
    "text": "Merged Pull Requests\n\nSupport to print dataclasses and tuples in REPL Added in support to print dataclasses and tuple in REPL.\nCI tests for LLVM 10, 14, 15 and 16 Added in CI tests to check with LLVM versions 10, 14, 15 & 16. LLVM 14 tests were failing on the GitHub CI, but I could not replicate it locally. We decided to remove it for now and open an issue about it. Therefore we currently only test with 10, 15 & 16 along with the default version of 11 that is used."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Week-8-and-9/index.html#issues-opened",
    "href": "blogs/posts/GSoC'24-LPython-Week-8-and-9/index.html#issues-opened",
    "title": "GSoC’24 - LPython: 8th & 9th Week",
    "section": "Issues Opened",
    "text": "Issues Opened\n\nSegfault while printing dataclass in REPL LPython segfaults with printing a very specific type of dataclass. On investigation, it looked like a bug in LLVM, but I am not sure.\nGitHub Workflow Fails with LLVM 14 Issue related to the failing CI tests on LLVM 14, that I could not replicate locally.\n\nThis week I plan on working on the BindPython ABI for the LLVM backend. The main goal is to add support to call CPython code from LPython for the LLVM backend. Presently, we support calling CPython code while using the C backend."
  },
  {
    "objectID": "blogs/posts/GSoC'23-GNU-Octave-My-Project/index.html",
    "href": "blogs/posts/GSoC'23-GNU-Octave-My-Project/index.html",
    "title": "Google Summer of Code 2023 - My Project",
    "section": "",
    "text": "octave-pythonic is an octave package used to incorporate python libraries and features in octave using the cpython interpreter. Currently, octave-pythonic only supports python versions less than 3.10. But the latest python version is 3.11. The package has not been updated for a long time. I propose to improve the state of the package. Making sure that octave-pythonic support the latest versions of python. Adding the missing features to the project. Fixing bugs from the bug tracker at GitLab. Implementing a python wrapper around octave types to use in python, adding support for function callbacks and handles, and also adding support to use octave from python.\n\n\n\n\nMove the octave-pythonic project which is currently owned by a single person to the GNU Octave group.\nSupport the latest version of Python. Current Pythonic only supports Python versions up to 3.9, but 3.11 is the latest version of Python.\nUpdate CI/CD to test Pythonic with multiple versions of Octave and Python.\nProvide a proof of concept of a pyimport command. To use Python functions, namespaces, and any other symbols in the Octave workspace.\nImplement complete destructor support of pyobject. This is required to free unused memory from a running process.\nImplement a new pyenv function to select the Python environment to be used with Pythonic at runtime.\nWindows Compatibility; Resolve open issues related to build failing on Windows and other bugs on Windows. Also, add CI/CD pipeline to test Pythonic on Windows.\nVerify existing issues on the dev tip of the Octave interpreter which needs to be fixed to be used in Pythonic.\nProvide a proof of concept of a wrapper around Octave objects. Passing Octave objects and operating on Octave objects should preferably create 0 copies.\nImprove Documentation; Add a user manual with sections that might include installation, basic usage, advanced usage, and development. Hopefully, build and publish it under GitLab Pages.\nSupport performing arithmetic and bit-wise operations on pyobjects.\nSupport slicing of Python sequences.\nImprove/update automated CI releases and adjust for new packages.octave.org changes.\n\n\n\n\n\nExtended deliverables depend on bug fixes or new features being implemented in the core Octave interpreter. These deliverables will be achieved if the necessary fixes/features have been implemented or get implemented during the course of my GSoC.\n\n\nSupport assignment on a Python dict. Or any Python mapping.\nSupport load and save to store Python objects on the disk.\nImprove exception handling and exception message. The Python stack trace is not displaced when an exception occurs.\n\n\n\n\n\nInitial discourse post: https://octave.discourse.group/t/gsoc-2023-proposal-to-improve-state-of-octave-pythonic/4032/1\nGSoC project page: https://summerofcode.withgoogle.com/programs/2023/projects/aeEAbtyR\nMerge Requests\n\nSupport python 3.10 & 3.11 and drops support for less then 3.7 Status: Merged on 26th May 2023\nUpdating gitlab CI/CD to use official gnu octave docker image Status: Opened on 26th May 2023\nSupport for destructor of pyobject Status: Opened on 26th May 2023\nAdd support to import modules using pyimport command Status: Opened on 26th May 2023\n\nBug Reports\n\noctave crashing while saving class object to a file at discourse Status: Fix at Octave version 8.3.0\ncrash while using subsasgn with struct and multiple subs value at savannah.\ndestructor is executed even if the constructor fails and throws an error at savannah.\n\nAdded new page at Pythonic Wiki, developer’s reference API\nLinks to my work on supporting HDF5 file format in octave\n\nProject at https://github.com/pantxo/oct-hdf5\nDraft pull request on implementation of h5disp function\nMerged pull request on implemented H5A.get_num_attrs\nMerged pull request; setting up GitHub actions for automated testing\n\nLinks to other blogs\n\nBlog to what I did in week 1\nBlog to what I did in the first 5 weeks"
  },
  {
    "objectID": "blogs/posts/GSoC'23-GNU-Octave-My-Project/index.html#abstract",
    "href": "blogs/posts/GSoC'23-GNU-Octave-My-Project/index.html#abstract",
    "title": "Google Summer of Code 2023 - My Project",
    "section": "",
    "text": "octave-pythonic is an octave package used to incorporate python libraries and features in octave using the cpython interpreter. Currently, octave-pythonic only supports python versions less than 3.10. But the latest python version is 3.11. The package has not been updated for a long time. I propose to improve the state of the package. Making sure that octave-pythonic support the latest versions of python. Adding the missing features to the project. Fixing bugs from the bug tracker at GitLab. Implementing a python wrapper around octave types to use in python, adding support for function callbacks and handles, and also adding support to use octave from python."
  },
  {
    "objectID": "blogs/posts/GSoC'23-GNU-Octave-My-Project/index.html#main-deliverables",
    "href": "blogs/posts/GSoC'23-GNU-Octave-My-Project/index.html#main-deliverables",
    "title": "Google Summer of Code 2023 - My Project",
    "section": "",
    "text": "Move the octave-pythonic project which is currently owned by a single person to the GNU Octave group.\nSupport the latest version of Python. Current Pythonic only supports Python versions up to 3.9, but 3.11 is the latest version of Python.\nUpdate CI/CD to test Pythonic with multiple versions of Octave and Python.\nProvide a proof of concept of a pyimport command. To use Python functions, namespaces, and any other symbols in the Octave workspace.\nImplement complete destructor support of pyobject. This is required to free unused memory from a running process.\nImplement a new pyenv function to select the Python environment to be used with Pythonic at runtime.\nWindows Compatibility; Resolve open issues related to build failing on Windows and other bugs on Windows. Also, add CI/CD pipeline to test Pythonic on Windows.\nVerify existing issues on the dev tip of the Octave interpreter which needs to be fixed to be used in Pythonic.\nProvide a proof of concept of a wrapper around Octave objects. Passing Octave objects and operating on Octave objects should preferably create 0 copies.\nImprove Documentation; Add a user manual with sections that might include installation, basic usage, advanced usage, and development. Hopefully, build and publish it under GitLab Pages.\nSupport performing arithmetic and bit-wise operations on pyobjects.\nSupport slicing of Python sequences.\nImprove/update automated CI releases and adjust for new packages.octave.org changes."
  },
  {
    "objectID": "blogs/posts/GSoC'23-GNU-Octave-My-Project/index.html#extended-deliverables",
    "href": "blogs/posts/GSoC'23-GNU-Octave-My-Project/index.html#extended-deliverables",
    "title": "Google Summer of Code 2023 - My Project",
    "section": "",
    "text": "Extended deliverables depend on bug fixes or new features being implemented in the core Octave interpreter. These deliverables will be achieved if the necessary fixes/features have been implemented or get implemented during the course of my GSoC.\n\n\nSupport assignment on a Python dict. Or any Python mapping.\nSupport load and save to store Python objects on the disk.\nImprove exception handling and exception message. The Python stack trace is not displaced when an exception occurs."
  },
  {
    "objectID": "blogs/posts/GSoC'23-GNU-Octave-My-Project/index.html#important-links-and-references",
    "href": "blogs/posts/GSoC'23-GNU-Octave-My-Project/index.html#important-links-and-references",
    "title": "Google Summer of Code 2023 - My Project",
    "section": "",
    "text": "Initial discourse post: https://octave.discourse.group/t/gsoc-2023-proposal-to-improve-state-of-octave-pythonic/4032/1\nGSoC project page: https://summerofcode.withgoogle.com/programs/2023/projects/aeEAbtyR\nMerge Requests\n\nSupport python 3.10 & 3.11 and drops support for less then 3.7 Status: Merged on 26th May 2023\nUpdating gitlab CI/CD to use official gnu octave docker image Status: Opened on 26th May 2023\nSupport for destructor of pyobject Status: Opened on 26th May 2023\nAdd support to import modules using pyimport command Status: Opened on 26th May 2023\n\nBug Reports\n\noctave crashing while saving class object to a file at discourse Status: Fix at Octave version 8.3.0\ncrash while using subsasgn with struct and multiple subs value at savannah.\ndestructor is executed even if the constructor fails and throws an error at savannah.\n\nAdded new page at Pythonic Wiki, developer’s reference API\nLinks to my work on supporting HDF5 file format in octave\n\nProject at https://github.com/pantxo/oct-hdf5\nDraft pull request on implementation of h5disp function\nMerged pull request on implemented H5A.get_num_attrs\nMerged pull request; setting up GitHub actions for automated testing\n\nLinks to other blogs\n\nBlog to what I did in week 1\nBlog to what I did in the first 5 weeks"
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-My-Project/index.html",
    "href": "blogs/posts/GSoC'24-LPython-My-Project/index.html",
    "title": "Google Summer of Code 2024 - My Project",
    "section": "",
    "text": "LPython is a statically typed compiled programming language with syntax inspired by Python programming language. LPython also aims to have first-class support to work with Python and C libraries. LPython has multiple backend targets like C, C++, and LLVM IR that can be compiled to target executables with the appropriate C/C++ compiler or the LLVM compiler toolchain. As LPython is statically typed and ahead-of-time compiled it offers much better performance than cpython. The current state of LPython is not feature-complete nor bug-free. I propose to add an interactive shell for LPython so that the developers can quickly prototype ideas, and improve the debug information generated for the LLVM backend so that users can execute a single line of code at a time and pretty print variables and complex datatypes.\nI also have two additional extended goals\n\nFix memory leaks that occur in the target executable: When using any complex datatypes like list, tuple, or dict, the data is allocated on the heap. But the heap allocated memory is never freed.\nImplement the BindPython ABI for the LLVM backend: The @pythoncall decorator to call into the CPython code is not implemented in the LLVM backend.\n\n\n\n\nI had two meetings with my mentors. In the first meeting, we discussed the implementation details of the REPL. The first half of the second meeting was a code review where my mentor went through the open PRs at the time. In the second half of the meeting, we discussed how to print the top-level expressions in REPL.\nI have implemented a very basic version of the REPL in this PR. And it has been merged. Last few days I have been testing this basic REPL and have been fixing bugs that I have come across. LFortran is a sister project to LPython. LFortan and LPython share the same architecture. They have a front end that parses the source programming language and constructs something called Abstract Semantic Representation (ASR). We have a common backend that consumes this ASR to produce the final target code. Any changes to the backend i.e. at the ASR or target code generation level should be tested in both LFortran and LPython.\n\n\n\nFixes complex datatype’s symbol duplication bug while using interactive We had a bug in which if we declare a variable of list, dict, tuple, or set datatype, it would be (re)declared at each REPL evaluation loop.\nRemoving _lfortran_caimag and _lfortran_zaimag functions These 2 functions were declared but not defined anywhere.\nAvoiding name mangling while interactive is true of the passes on the ASR collects all the top-level expressions and creates a function out of it. The ABI of this function depends on the return type of the function. The target code generator would mangle the name of the function in a different manner depending on the ABI. This name mangling would make it difficult to find and execute the correct function at the REPL.\nCombine global_init and global_stmts functions into global_stmts We collected all the top-level symbol declarations separately then other statements and expressions. The declarations would be put into the global_init function and other statements and expressions into global_stmts. The global_init would run first and then global_stmts. This behavior caused problems where the declarations would be overwritten or modified incorrectly when a declaration depended on some computed value that was put into global_stmts. You can find the actual bug report on GitHub."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-My-Project/index.html#about-my-project",
    "href": "blogs/posts/GSoC'24-LPython-My-Project/index.html#about-my-project",
    "title": "Google Summer of Code 2024 - My Project",
    "section": "",
    "text": "LPython is a statically typed compiled programming language with syntax inspired by Python programming language. LPython also aims to have first-class support to work with Python and C libraries. LPython has multiple backend targets like C, C++, and LLVM IR that can be compiled to target executables with the appropriate C/C++ compiler or the LLVM compiler toolchain. As LPython is statically typed and ahead-of-time compiled it offers much better performance than cpython. The current state of LPython is not feature-complete nor bug-free. I propose to add an interactive shell for LPython so that the developers can quickly prototype ideas, and improve the debug information generated for the LLVM backend so that users can execute a single line of code at a time and pretty print variables and complex datatypes.\nI also have two additional extended goals\n\nFix memory leaks that occur in the target executable: When using any complex datatypes like list, tuple, or dict, the data is allocated on the heap. But the heap allocated memory is never freed.\nImplement the BindPython ABI for the LLVM backend: The @pythoncall decorator to call into the CPython code is not implemented in the LLVM backend."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-My-Project/index.html#work-done-so-far",
    "href": "blogs/posts/GSoC'24-LPython-My-Project/index.html#work-done-so-far",
    "title": "Google Summer of Code 2024 - My Project",
    "section": "",
    "text": "I had two meetings with my mentors. In the first meeting, we discussed the implementation details of the REPL. The first half of the second meeting was a code review where my mentor went through the open PRs at the time. In the second half of the meeting, we discussed how to print the top-level expressions in REPL.\nI have implemented a very basic version of the REPL in this PR. And it has been merged. Last few days I have been testing this basic REPL and have been fixing bugs that I have come across. LFortran is a sister project to LPython. LFortan and LPython share the same architecture. They have a front end that parses the source programming language and constructs something called Abstract Semantic Representation (ASR). We have a common backend that consumes this ASR to produce the final target code. Any changes to the backend i.e. at the ASR or target code generation level should be tested in both LFortran and LPython.\n\n\n\nFixes complex datatype’s symbol duplication bug while using interactive We had a bug in which if we declare a variable of list, dict, tuple, or set datatype, it would be (re)declared at each REPL evaluation loop.\nRemoving _lfortran_caimag and _lfortran_zaimag functions These 2 functions were declared but not defined anywhere.\nAvoiding name mangling while interactive is true of the passes on the ASR collects all the top-level expressions and creates a function out of it. The ABI of this function depends on the return type of the function. The target code generator would mangle the name of the function in a different manner depending on the ABI. This name mangling would make it difficult to find and execute the correct function at the REPL.\nCombine global_init and global_stmts functions into global_stmts We collected all the top-level symbol declarations separately then other statements and expressions. The declarations would be put into the global_init function and other statements and expressions into global_stmts. The global_init would run first and then global_stmts. This behavior caused problems where the declarations would be overwritten or modified incorrectly when a declaration depended on some computed value that was put into global_stmts. You can find the actual bug report on GitHub."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Week-7/index.html",
    "href": "blogs/posts/GSoC'24-LPython-Week-7/index.html",
    "title": "GSoC’24 - LPython: 7th Week",
    "section": "",
    "text": "This was a fun week again. My mentor Ondrej attended the SciPy conference and also presented LPython in his talk. At the start of the week, he asked me about the status of REPL and Jupyter Notebook support for LPython. We have good, usable, but not feature complete REPL, but we have no Jupyter Notebook support was my reply. Within 2 to 3 days, I added support for Jupyter Notebook by adapting the code from LFortran’s repository (LFortran already supports Jupyter Notebooks), and fixed bugs related to the failing CI caused by updating the dependencies versions."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Week-7/index.html#merged-pull-request",
    "href": "blogs/posts/GSoC'24-LPython-Week-7/index.html#merged-pull-request",
    "title": "GSoC’24 - LPython: 7th Week",
    "section": "Merged Pull Request",
    "text": "Merged Pull Request\n\nJupyter Notebook Support to use LPython in Jupyter Notebooks, and fix for the CI failures.\nSupport to print lists in REPL Adds support to print top-level expression of list type.\nUnderscore: _ variable in REPL This PR introduces the _ (underscore) variable in LPython’s REPL (like in CPython’s REPL). The _ variable holds the value of the last evaluated expression from the previous REPL block."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Week-7/index.html#open-pull-request",
    "href": "blogs/posts/GSoC'24-LPython-Week-7/index.html#open-pull-request",
    "title": "GSoC’24 - LPython: 7th Week",
    "section": "Open Pull Request",
    "text": "Open Pull Request\n\nCI tests for LLVM 10, 14, 15 and 16 The CI fails for LLVM version 14 only, and I am not able to reproduce the bug locally."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Week-7/index.html#issue-created",
    "href": "blogs/posts/GSoC'24-LPython-Week-7/index.html#issue-created",
    "title": "GSoC’24 - LPython: 7th Week",
    "section": "Issue Created",
    "text": "Issue Created\n\nBug with bit_length function I added a comment in an existing issue concerning the bit_length function. The comment is specific to interactive mode, where no LLVM IR is generated.\n\nThis week I will be working on support to print other aggregate datatypes in interactive mode. I will also look into the failing CI of LLVM 14."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Completion/index.html",
    "href": "blogs/posts/GSoC'24-LPython-Completion/index.html",
    "title": "GSoC’24 - LPython: Project Completion",
    "section": "",
    "text": "This is the final report of my work done during the Google Summer of Code 2024 period with the Python Software Foundation, LPython sub-organisation.\nLPython is a statically typed, compiled variant of Python. It is much faster than CPython (the most common Python interpreter). LPython is able to be fast because of the static types as compared to dynamic types in Python and being a compiled language. Our compiler can also be used to trans-compiler Python code to C, C++ and Fortran code. LFortran is a sister project to LPython. Both use the same back-end for target code generation and other compiler optimisations.\nI implemented a REPL (read-evaluate-print-loop) shell for LPython. This required modification of the way we compile. I used LLVM’s JIT compiler to just-in-time compile the code. Work on REPL laid the groundwork for implementing a Jupyter Kernel. Jupyter Kernel had already been implemented for LFortran, and I only had to adapt it to work with LPython. Following that, I worked on interoperability of LPython with CPython. We intend to provide first class support to use CPython libraries within LPython."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Completion/index.html#detailed-description",
    "href": "blogs/posts/GSoC'24-LPython-Completion/index.html#detailed-description",
    "title": "GSoC’24 - LPython: Project Completion",
    "section": "Detailed Description",
    "text": "Detailed Description\n\nRead Evaluate Print Loop\nI faced a lot of issues initially. Our code base was designed for ahead-of-time compilation. I had to adapt it to work for just-in-time compilation. I was using LLVM 11 for development. But the project intends to support all the LLVM versions from 10. This required additional care for changes in LLVM’s API across versions.\nPull Requests\n\nInteractive shell implementation Initial implementation of interactive shell\nFix ASR verify pass error while using Interactive ASR verify is used to check if the syntax tree generated is valid. While using the interactive mode, there were cases where the syntax tree generated was valid but the ASR verify pass would throw error saying it is invalid.\nInitial test for Interactive Adding in the initial tests to check and validate the workings of REPL.\nPrinting top-level expressions that are evaluated on each REPL execution loop\n\nPrinting top-level Expressions\nSupport to print u32 and u64 in REPL\nSupport to print i8, u8, i16 and u16 in Interactive mode\nREPL str support\nsupport printing boolean in REPL\nSupport to print dataclasses and tuples in REPL\n\nCI tests for LLVM 10, 14, 15 and 16 I added in automated GitHub workflows to compile and test LPython against multiple versions of LLVM that we intend to support.\nUnderscore: _ variable in REPL The underscore variable _ is used to retrieve and use the value of the previously evaluated expression in REPL. LPython is statically typed, but the type of evaluated expression can change in each loop. Therefore, the _ is name mangled to be something else in each REPL execution loop.\n\nThere are a few missing features. Error messages that are produced in REPL are fuzzy. Top level printing of a few aggregate datatypes are not yet implemented.\n\n\nJupyter Kernel\nA single pull request with more than 1000 lines of code changes. Jupyter Kernel We are using xeus library to build LPython’s Jupyter Kernel. xeus is a C++ library used to create Jupyter Kernels.\n\n\nInteroperability with CPython\nLPython previously used to support using CPython libraries only when using the C back-end (i.e. trans-compiling LPython code to C source code). I have written an ASR pass, that work on the syntax tree to produce or generate the additional logic for type conversions between CPython and LPython types, and function resolution to find and call CPython functions from LPython. As this implementation works on the syntax tree directly, all the back-ends can use it out of the box without any additional changes specific to each back-end.\nPull Requests\n\nBindPython ABI Implemented function resolution and type conversions for primitive datatypes.\nBindPython ASR Pass: aggregate type conversions Implemented type conversions for aggregate type such as list, tuple, set, and dict.\n\nThere is a small bug in this implementation. There is no error handling. This is required when type conversions are not possible or function resolution fails. Presently, it is undefined behaviour. I will be fixing this within a week.\n\n\nPull Requests related to Bug Fixes\n\nPrevent calling abort while handling the SIGABRT signal\nCombine global_init and global_stmts functions into global_stmts This fixed a bug in which variables would be initialised wrongly if it depended on other variable.\navoiding name mangling while interactive is true This was required to get the function symbols while using the REPL shell.\nremoving _lfortran_caimag and _lfortran_zaimag functions We had declarations for some functions that did not have any definition.\nSymbol duplication bugs while using REPL: Variable of specific datatype would be redefined in each REPL loop.\n\nFixes complex datatype’s symbol duplication bug while using interactive\nfix array symbol duplication in interactive mode\n\ncombining duplicated function into a single templated function To reduce code duplication and improve code readability and debugability.\n\n\n\nPull requests that were not merged\n\nSupport to redefine of function in REPL Implementation of function redefinition is tricky with compiled languages. There are many questions regarding the implementation details; Should the previous definition of the function be kept in memory or deallocated? What if, there is a pointer to the old definition? Should it be updated? If g calls f, and we redefine f, should g now be calling the new definition of f or the old definition of f? I implemented according to what felt correct to me. But then when we compared it to the behaviour of CPython, it was decided to hold off further work. You can find the detailed explanation in this blog.\n\n\n\nIssues Opened\n\nSegfault while printing dataclass in REPL LPython experiences a segmentation fault and crashes when trying to print a specific type of dataclass in REPL. I suspect that the issue is at the LLVM’s code, and not our code base.\nGitHub Workflow Fails with LLVM 14\nBlank line within an indented block of code is wrongly parsed on Windows Windows uses \\r\\n to represent end of a line. Whereas other operating systems use \\n. Due to this difference between the end of line representation, the parse ends up parsing the source code incorrectly."
  },
  {
    "objectID": "blogs/posts/GSoC'24-LPython-Completion/index.html#acknowledgement",
    "href": "blogs/posts/GSoC'24-LPython-Completion/index.html#acknowledgement",
    "title": "GSoC’24 - LPython: Project Completion",
    "section": "Acknowledgement",
    "text": "Acknowledgement\nI would like to thank Google Summer of Code for providing this opportunity, and my mentors Ubaid Shaikh and Ondřej Čertík for there guidance and help throughout the project."
  }
]